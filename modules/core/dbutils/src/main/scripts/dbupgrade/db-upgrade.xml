
<project name="db-upgrade" default="upgrade" basedir=".">

<!--
This target upgrades a database schema.  The parameters that it accepts are:
  jdbc.url              = the jdbc url of the database to upgrade
  jdbc.user             = the user to connect to the database as
  jdbc.password         = the database user's password
  target.schema.version = the schema version to upgrade to. If this is omitted
                          then the schema is upgraded to the latest version.

This target assumes that the taskdefs for the dbupgrade ant task have already been defined.
-->

<target name="upgrade">

<echo>
DB Upgrade:
   JDBC URL: ${jdbc.url}
   JDBC User: ${jdbc.user}
   Update Version: ${target.schema.version}
</echo>

<dbupgrade
   jdbcUrl="${jdbc.url}"
   jdbcUser="${jdbc.user}"
   jdbcPassword="${jdbc.password}"
   valueColumn="PROPERTY_VALUE"
   table="RHQ_SYSTEM_CONFIG"
   keyColumn="PROPERTY_KEY"
   keyMatch="DB_SCHEMA_VERSION"
   targetSchemaVersion="${target.schema.version}">

    <schemaSpec version="2.0">
        <!-- Empty initial schema to avoid install failure on default latest schema version -->
    </schemaSpec>

    <schemaSpec version="2.1">
        <!-- Keep the columnType VARCHAR2, but increase size;
            (see note for RHQ_ALERT_CONDITION table in alert-schema.xml for more info) -->
        <schema-alterColumn
            table="RHQ_ALERT_CONDITION"
            column="OPTION_STATUS"
            columnType="VARCHAR2"
            precision="256" />
    </schemaSpec>

    <schemaSpec version="2.2">
        <!-- RHQ-481 make resource names longer -->
        <schema-alterColumn
            table="RHQ_RESOURCE"
            column="NAME"
            columnType="VARCHAR2"
            precision="500" />
    </schemaSpec>

    <schemaSpec version="2.3">
        <!-- RHQ-666 - Don't require resource name at creation time -->
        <schema-alterColumn
            table="RHQ_CREATE_RES_HIST"
            column="CREATED_RESOURCE_NAME"
            columnType="VARCHAR2"
            precision="500" />
    </schemaSpec>

   <!-- RHQ-669 - Add metadata to package type to indicate architecture support -->
   <schemaSpec version="2.4">
        <schema-addColumn
            table="RHQ_PACKAGE_TYPE"
            column="SUPPORTS_ARCHITECTURE"
            columnType="BOOLEAN" />

        <schema-directSQL>
            <statement targetDBVendor="postgresql"
                       desc="Updating existing package types with default for SUPPORTS_ARCHITECTURE flag">
                UPDATE RHQ_PACKAGE_TYPE SET SUPPORTS_ARCHITECTURE = FALSE
            </statement>
            <statement targetDBVendor="oracle"
                       desc="Updating existing package types with default for SUPPORTS_ARCHITECTURE flag">
                UPDATE RHQ_PACKAGE_TYPE SET SUPPORTS_ARCHITECTURE = 0
            </statement>
        </schema-directSQL>

        <schema-alterColumn
           table="RHQ_PACKAGE_TYPE"
           column="SUPPORTS_ARCHITECTURE"
           nullable="FALSE" />

   </schemaSpec>

   <!-- RHQ-176 - Add notes column to content requests -->
   <schemaSpec version="2.5">
        <schema-addColumn
            table="RHQ_CONTENT_REQ"
            column="NOTES"
            columnType="VARCHAR2"
            precision="512" />
   </schemaSpec>

   <!-- rhq-488 - RHQ High Availability / Failover Support -->
   <schemaSpec version="2.6">

        <!-- RHQ_AFFINITY_GROUP -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_AFFINITY_GROUP">
                  CREATE TABLE RHQ_AFFINITY_GROUP ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_AFFINITY_GROUP" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_AFFINITY_GROUP_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_AFFINITY_GROUP">
                ALTER TABLE RHQ_AFFINITY_GROUP ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_AFFINITY_GROUP" column="NAME" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_AFFINITY_GROUP" column="NAME" nullable="FALSE"/>

        <!-- RHQ_SERVER -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_SERVER">
                  CREATE TABLE RHQ_SERVER ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_SERVER" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_SERVER_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_SERVER">
                ALTER TABLE RHQ_SERVER ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_SERVER" column="NAME" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_SERVER" column="NAME" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="ADDRESS" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_SERVER" column="ADDRESS" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="PORT" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_SERVER" column="PORT" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="SECURE_PORT" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_SERVER" column="SECURE_PORT" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_SERVER" column="CTIME" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="AFFINITY_GROUP_ID" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Creating RHQ_SERVER foreign key relation to RHQ_AFFINITY_GROUP">
                  ALTER TABLE RHQ_SERVER
                  ADD CONSTRAINT RHQ_SERVER_AG_ID_FK
                  FOREIGN KEY (AFFINITY_GROUP_ID)
                  REFERENCES RHQ_AFFINITY_GROUP (ID)
             </statement>
        </schema-directSQL>

        <!-- RHQ_AGENT modifications -->
          <schema-addColumn   table="RHQ_AGENT" column="AFFINITY_GROUP_ID" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Creating RHQ_AGENT foreign key relation to RHQ_AFFINITY_GROUP">
                  ALTER TABLE RHQ_AGENT
                  ADD CONSTRAINT RHQ_AGENT_AG_ID_FK
                  FOREIGN KEY (AFFINITY_GROUP_ID)
                  REFERENCES RHQ_AFFINITY_GROUP (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_AGENT" column="SERVER_ID" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Creating RHQ_AGENT foreign key relation to RHQ_SERVER">
                  ALTER TABLE RHQ_AGENT
                  ADD CONSTRAINT RHQ_AGENT_SERVER_ID_FK
                  FOREIGN KEY (SERVER_ID)
                  REFERENCES RHQ_SERVER (ID)
             </statement>
        </schema-directSQL>

        <!-- RHQ_PARTITION_EVENT -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_PARTITION_EVENT">
                  CREATE TABLE RHQ_PARTITION_EVENT ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_PARTITION_EVENT_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_PARTITION_EVENT">
                ALTER TABLE RHQ_PARTITION_EVENT ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_EVENT" column="SUBJECT_NAME" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="SUBJECT_NAME" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_PARTITION_EVENT" column="EVENT_TYPE" columnType="VARCHAR2" precision="50"/>
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="EVENT_TYPE" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_PARTITION_EVENT" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="CTIME" nullable="FALSE"/>

        <!-- RHQ_PARTITION_DETAILS -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_PARTITION_DETAILS">
                  CREATE TABLE RHQ_PARTITION_DETAILS ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_PARTITION_DETAILS_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_PARTITION_DETAILS">
                ALTER TABLE RHQ_PARTITION_DETAILS ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_DETAILS" column="PARTITION_EVENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="PARTITION_EVENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_PARTITION_DETAILS foreign key relation to RHQ_PARTITION_EVENT">
                  ALTER TABLE RHQ_PARTITION_DETAILS
                  ADD CONSTRAINT RHQ_PD_EVENT_ID_FK
                  FOREIGN KEY (PARTITION_EVENT_ID)
                  REFERENCES RHQ_PARTITION_EVENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_DETAILS" column="AGENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="AGENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_PARTITION_DETAILS foreign key relation to RHQ_AGENT">
                  ALTER TABLE RHQ_PARTITION_DETAILS
                  ADD CONSTRAINT RHQ_PD_AGENT_ID_FK
                  FOREIGN KEY (AGENT_ID)
                  REFERENCES RHQ_AGENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_DETAILS" column="SERVER_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="SERVER_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_PARTITION_DETAILS foreign key relation to RHQ_SERVER">
                  ALTER TABLE RHQ_PARTITION_DETAILS
                  ADD CONSTRAINT RHQ_PD_SERVER_ID_FK
                  FOREIGN KEY (SERVER_ID)
                  REFERENCES RHQ_SERVER (ID)
             </statement>
        </schema-directSQL>

        <!-- RHQ_FAILOVER_LIST -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_FAILOVER_LIST">
                  CREATE TABLE RHQ_FAILOVER_LIST ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_FAILOVER_LIST_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_FAILOVER_LIST">
                ALTER TABLE RHQ_FAILOVER_LIST ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_LIST" column="PARTITION_EVENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="PARTITION_EVENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_LIST foreign key relation to RHQ_PARTITION_EVENT">
                  ALTER TABLE RHQ_FAILOVER_LIST
                  ADD CONSTRAINT RHQ_FL_EVENT_ID_FK
                  FOREIGN KEY (PARTITION_EVENT_ID)
                  REFERENCES RHQ_PARTITION_EVENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_LIST" column="AGENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="AGENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_LIST foreign key relation to RHQ_AGENT">
                  ALTER TABLE RHQ_FAILOVER_LIST
                  ADD CONSTRAINT RHQ_FL_AGENT_ID_FK
                  FOREIGN KEY (AGENT_ID)
                  REFERENCES RHQ_AGENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_LIST" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="CTIME" nullable="FALSE"/>

        <!-- RHQ_FAILOVER_DETAILS -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_FAILOVER_DETAILS">
                  CREATE TABLE RHQ_FAILOVER_DETAILS ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_FAILOVER_DETAILS_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_FAILOVER_DETAILS">
                ALTER TABLE RHQ_FAILOVER_DETAILS ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_DETAILS" column="FAILOVER_LIST_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="FAILOVER_LIST_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_DETAILS foreign key relation to FAILOVER_LIST_ID">
                  ALTER TABLE RHQ_FAILOVER_DETAILS
                  ADD CONSTRAINT RHQ_FD_FAILOVER_LIST_ID_FK
                  FOREIGN KEY (FAILOVER_LIST_ID)
                  REFERENCES RHQ_FAILOVER_LIST (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_DETAILS" column="SERVER_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="SERVER_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_DETAILS foreign key relation to RHQ_SERVER">
                  ALTER TABLE RHQ_FAILOVER_DETAILS
                  ADD CONSTRAINT RHQ_FD_SERVER_ID_FK
                  FOREIGN KEY (SERVER_ID)
                  REFERENCES RHQ_SERVER (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_DETAILS" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="CTIME" nullable="FALSE"/>

   </schemaSpec>

   <schemaSpec version="2.7">
        <schema-addColumn   table="RHQ_AGENT" column="STATUS" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Updating existing agents with default STATUS flag">
                 UPDATE RHQ_AGENT SET STATUS = 0
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_AGENT" column="STATUS" default="0" />
   </schemaSpec>

   <schemaSpec version="2.8">
        <schema-addColumn   table="RHQ_SERVER" column="OPERATION_MODE" columnType="VARCHAR2" precision="32"/>
        <schema-directSQL>
             <statement desc="Updating existing servers with default OPERATION_MODE flag">
                 UPDATE RHQ_SERVER SET OPERATION_MODE = 'NORMAL'
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_SERVER" column="OPERATION_MODE" nullable="FALSE"/>

        <schema-directSQL>
            <statement desc="Creating RHQ_SERVER unique constraint on NAME">
                CREATE UNIQUE INDEX rhq_server_name_unique ON rhq_server (name)
            </statement>
        </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.9">
      <schema-addColumn table="RHQ_FAILOVER_DETAILS" column="ORDINAL" columnType="INTEGER" />
   </schemaSpec>

   <schemaSpec version="2.10">
      <schema-deleteColumn table="RHQ_FAILOVER_DETAILS" column="CTIME" />
   </schemaSpec>

   <schemaSpec version="2.11">
      <schema-alterColumn table="RHQ_ALERT_NOTIFICATION" column="ALERT_DEFINITION_ID" nullable="TRUE"/>
   </schemaSpec>

   <schemaSpec version="2.12">
      <schema-deleteColumn table="RHQ_SERVER" column="PORT" />
      <schema-deleteColumn table="RHQ_SERVER" column="SECURE_PORT" />

      <schema-addColumn table="RHQ_SERVER" column="BIND_PORT" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default BIND_PORT=7080">
            UPDATE RHQ_SERVER SET BIND_PORT = 7080
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="BIND_PORT" nullable="FALSE"/>

      <schema-addColumn table="RHQ_SERVER" column="TRANSPORT" columnType="VARCHAR2" precision="32"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default TRANSPORT=servlet">
            UPDATE RHQ_SERVER SET TRANSPORT = 'servlet'
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="TRANSPORT" nullable="FALSE"/>

      <schema-addColumn table="RHQ_SERVER" column="TRANSPORT_PARAMS" columnType="VARCHAR2" precision="512"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default TRANSPORT_PARAMS=/jboss-remoting-servlet-invoker/ServerInvokerServlet">
            UPDATE RHQ_SERVER SET TRANSPORT_PARAMS = '/jboss-remoting-servlet-invoker/ServerInvokerServlet'
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="TRANSPORT_PARAMS" nullable="FALSE"/>

      <schema-addColumn table="RHQ_SERVER" column="COMPUTE_POWER" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default COMPUTE_POWER=1">
            UPDATE RHQ_SERVER SET COMPUTE_POWER = 1
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="COMPUTE_POWER" nullable="FALSE"/>

   </schemaSpec>

   <schemaSpec version="2.13">
      <schema-deleteColumn table="RHQ_SERVER" column="BIND_PORT" />
      <schema-deleteColumn table="RHQ_SERVER" column="TRANSPORT" />
      <schema-deleteColumn table="RHQ_SERVER" column="TRANSPORT_PARAMS" />

      <schema-addColumn table="RHQ_SERVER" column="PORT" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default PORT=7080">
            UPDATE RHQ_SERVER SET PORT = 7080
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="PORT" nullable="FALSE"/>
      <schema-addColumn table="RHQ_SERVER" column="SECURE_PORT" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default SECURE_PORT=7443">
            UPDATE RHQ_SERVER SET SECURE_PORT = 7443
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="SECURE_PORT" nullable="FALSE"/>
   </schemaSpec>

   <!-- RHQ-720 - Add read_only column to alert definitions table -->
   <schemaSpec version="2.14">
        <schema-addColumn
            table="RHQ_ALERT_DEFINITION"
            column="READ_ONLY"
            columnType="BOOLEAN" />

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Updating existing alert definitions with default for READ_ONLY flag">
              UPDATE RHQ_ALERT_DEFINITION SET READ_ONLY = FALSE
          </statement>
          <statement targetDBVendor="oracle"
            desc="Updating existing alert definitions with default for READ_ONLY flag">
              UPDATE RHQ_ALERT_DEFINITION SET READ_ONLY = 0
          </statement>
      </schema-directSQL>

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Setting alert definition READ_ONLY DEFAULT">
              ALTER TABLE RHQ_ALERT_DEFINITION ALTER COLUMN READ_ONLY SET DEFAULT FALSE
          </statement>
          <statement targetDBVendor="oracle"
                     desc="Setting alert definition READ_ONLY DEFAULT">
             ALTER TABLE RHQ_ALERT_DEFINITION MODIFY READ_ONLY DEFAULT 0
          </statement>
      </schema-directSQL>

      <schema-alterColumn table="RHQ_ALERT_DEFINITION" column="READ_ONLY" nullable="FALSE" />
   </schemaSpec>

   <schemaSpec version="2.15">
      <schema-addColumn table="RHQ_PARTITION_EVENT" column="EXECUTION_STATUS" columnType="VARCHAR2" precision="32"/>
      <schema-directSQL>
         <statement desc="Updating existing partition events with default EXECUTION_STATUS=COMPLETED">
            UPDATE RHQ_PARTITION_EVENT SET EXECUTION_STATUS = 'COMPLETED'
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_PARTITION_EVENT" column="EXECUTION_STATUS" nullable="FALSE"/>
   </schemaSpec>

   <schemaSpec version="2.16">
      <schema-addColumn table="RHQ_PARTITION_DETAILS" column="AGENT_NAME" columnType="VARCHAR2" precision="255"/>
      <schema-addColumn table="RHQ_PARTITION_DETAILS" column="SERVER_NAME" columnType="VARCHAR2" precision="255"/>

      <schema-directSQL>
         <statement desc="Updating existing partition events details with default AGENT_NAME">
            UPDATE RHQ_PARTITION_DETAILS SET AGENT_NAME = 'UNKNOWN'
         </statement>
      </schema-directSQL>
      <schema-directSQL>
         <statement desc="Updating existing partition events details with known agents">
            UPDATE RHQ_PARTITION_DETAILS
            SET AGENT_NAME = ( SELECT RHQ_AGENT.NAME
                               FROM RHQ_AGENT
                               WHERE RHQ_AGENT.ID = RHQ_PARTITION_DETAILS.AGENT_ID )
         </statement>
      </schema-directSQL>

      <schema-directSQL>
         <statement desc="Updating existing partition events details with default SERVER_NAME">
            UPDATE RHQ_PARTITION_DETAILS SET SERVER_NAME = 'UNKNOWN'
         </statement>
      </schema-directSQL>
      <schema-directSQL>
         <statement desc="Updating existing partition events details with known servers">
            UPDATE RHQ_PARTITION_DETAILS
            SET SERVER_NAME = ( SELECT RHQ_SERVER.NAME
                                FROM RHQ_SERVER
                                WHERE RHQ_SERVER.ID = RHQ_PARTITION_DETAILS.SERVER_ID )
         </statement>
      </schema-directSQL>

      <schema-deleteColumn table="RHQ_PARTITION_DETAILS" column="AGENT_ID" />
      <schema-deleteColumn table="RHQ_PARTITION_DETAILS" column="SERVER_ID" />
   </schemaSpec>

   <!-- RHQ-786 - Add read_only column to alert definitions table -->
   <schemaSpec version="2.17">
      <schema-addColumn table="RHQ_ALERT" column="RECOVERY_ID" columnType="INTEGER" />

      <schema-directSQL>
          <statement desc="Updating existing alerts with default for recovery_id">
              UPDATE RHQ_ALERT SET RECOVERY_ID = 0
          </statement>
      </schema-directSQL>

      <schema-alterColumn table="RHQ_ALERT" column="RECOVERY_ID" nullable="FALSE" />

      <schema-addColumn table="RHQ_ALERT" column="WILL_RECOVER" columnType="BOOLEAN" />

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Updating existing alerts with default for WILL_RECOVER flag">
              UPDATE RHQ_ALERT SET WILL_RECOVER = FALSE
          </statement>
          <statement targetDBVendor="oracle"
            desc="Updating existing alerts with default for WILL_RECOVER flag">
              UPDATE RHQ_ALERT SET WILL_RECOVER = 0
          </statement>
      </schema-directSQL>

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Setting alert WILL_RECOVER DEFAULT">
              ALTER TABLE RHQ_ALERT ALTER COLUMN WILL_RECOVER SET DEFAULT FALSE
          </statement>
          <statement targetDBVendor="oracle"
                     desc="Setting alert WILL_RECOVER DEFAULT">
            ALTER TABLE RHQ_ALERT MODIFY WILL_RECOVER DEFAULT 0
          </statement>
      </schema-directSQL>

      <schema-alterColumn table="RHQ_ALERT" column="WILL_RECOVER" nullable="FALSE" />
   </schemaSpec>

   <schemaSpec version="2.18">
      <schema-addColumn table="RHQ_PARTITION_EVENT" column="EVENT_DETAIL" columnType="VARCHAR2" precision="512"/>

      <schema-addColumn table="RHQ_SERVER" column="MTIME" columnType="LONG"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default MTIME=CTIME">
            UPDATE RHQ_SERVER SET MTIME = CTIME
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="MTIME" nullable="FALSE"/>
   </schemaSpec>

   <schemaSpec version="2.19">
      <schema-addColumn table="RHQ_AGENT" column="LAST_AVAILABILITY_REPORT_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_AGENT.LAST_AVAILABILITY_REPORT timestamp to long">
            UPDATE RHQ_AGENT
            SET LAST_AVAILABILITY_REPORT_LONG = EXTRACT ( EPOCH FROM LAST_AVAILABILITY_REPORT )
            WHERE LAST_AVAILABILITY_REPORT IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_AGENT.LAST_AVAILABILITY_REPORT timestamp to long">
            UPDATE RHQ_AGENT
            SET LAST_AVAILABILITY_REPORT_LONG = 1000 *
            (   extract(day    from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE LAST_AVAILABILITY_REPORT IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_AGENT" column="LAST_AVAILABILITY_REPORT" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_AGENT.LAST_AVAILABILITY_REPORT column to match old schema expectations">
            ALTER TABLE RHQ_AGENT
            RENAME COLUMN LAST_AVAILABILITY_REPORT_LONG
            TO LAST_AVAILABILITY_REPORT
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.20">
      <schema-addColumn table="RHQ_ALERT_DAMPEN_EVENT" column="EVENT_TIMESTAMP_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_ALERT_DAMPEN_EVENT.EVENT_TIMESTAMP timestamp to long">
            UPDATE RHQ_ALERT_DAMPEN_EVENT
            SET EVENT_TIMESTAMP_LONG = EXTRACT ( EPOCH FROM EVENT_TIMESTAMP )
            WHERE EVENT_TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_ALERT_DAMPEN_EVENT.EVENT_TIMESTAMP timestamp to long">
            UPDATE RHQ_ALERT_DAMPEN_EVENT
            SET EVENT_TIMESTAMP_LONG = 1000 *
            (   extract(day    from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE EVENT_TIMESTAMP IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_ALERT_DAMPEN_EVENT" column="EVENT_TIMESTAMP" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_ALERT_DAMPEN_EVENT.EVENT_TIMESTAMP column to match old schema expectations">
            ALTER TABLE RHQ_ALERT_DAMPEN_EVENT
            RENAME COLUMN EVENT_TIMESTAMP_LONG
            TO EVENT_TIMESTAMP
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.21">
      <schema-addColumn table="RHQ_EVENT" column="TIMESTAMP_LONG" columnType="LONG" />
      <schema-addColumn table="RHQ_EVENT" column="ACK_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_EVENT.TIMESTAMP timestamp to long">
            UPDATE RHQ_EVENT
            SET TIMESTAMP_LONG = EXTRACT ( EPOCH FROM TIMESTAMP )
            WHERE TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_EVENT.ACK_TIME timestamp to long">
            UPDATE RHQ_EVENT
            SET ACK_TIME_LONG = EXTRACT ( EPOCH FROM ACK_TIME )
            WHERE ACK_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_EVENT.TIMESTAMP timestamp to long">
            UPDATE RHQ_EVENT
            SET TIMESTAMP_LONG = 1000 *
            (   extract(day    from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_EVENT.ACK_TIME timestamp to long">
            UPDATE RHQ_EVENT
            SET ACK_TIME_LONG = 1000 *
            (   extract(day    from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE ACK_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_EVENT" column="TIMESTAMP" />
      <schema-deleteColumn table="RHQ_EVENT" column="ACK_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_EVENT.TIMESTAMP column to match old schema expectations">
            ALTER TABLE RHQ_EVENT
            RENAME COLUMN TIMESTAMP_LONG
            TO TIMESTAMP
         </statement>
         <statement desc="Renaming new RHQ_EVENT.ACK_TIME column to match old schema expectations">
            ALTER TABLE RHQ_EVENT
            RENAME COLUMN ACK_TIME_LONG
            TO ACK_TIME
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.22">
      <!-- RHQ_CONTENT_SOURCE timestamp to long conversion -->
      <schema-addColumn table="RHQ_CONTENT_SOURCE" column="CREATION_TIME_LONG" columnType="LONG" />
      <schema-addColumn table="RHQ_CONTENT_SOURCE" column="LAST_MODIFIED_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CONTENT_SOURCE.CREATION_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET CREATION_TIME_LONG = EXTRACT ( EPOCH FROM CREATION_TIME )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CONTENT_SOURCE.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET LAST_MODIFIED_TIME_LONG = EXTRACT ( EPOCH FROM LAST_MODIFIED_TIME )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CONTENT_SOURCE.CREATION_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET CREATION_TIME_LONG = 1000 *
            (   extract(day    from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CONTENT_SOURCE.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET LAST_MODIFIED_TIME_LONG = 1000 *
            (   extract(day    from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_CONTENT_SOURCE" column="CREATION_TIME" />
      <schema-deleteColumn table="RHQ_CONTENT_SOURCE" column="LAST_MODIFIED_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_CONTENT_SOURCE.CREATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CONTENT_SOURCE
            RENAME COLUMN CREATION_TIME_LONG
            TO CREATION_TIME
         </statement>
         <statement desc="Renaming new RHQ_CONTENT_SOURCE.LAST_MODIFIED_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CONTENT_SOURCE
            RENAME COLUMN LAST_MODIFIED_TIME_LONG
            TO LAST_MODIFIED_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_CHANNEL timestamp to long conversion -->
      <schema-addColumn table="RHQ_CHANNEL" column="CREATION_TIME_LONG" columnType="LONG" />
      <schema-addColumn table="RHQ_CHANNEL" column="LAST_MODIFIED_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CHANNEL.CREATION_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET CREATION_TIME_LONG = EXTRACT ( EPOCH FROM CREATION_TIME )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CHANNEL.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET LAST_MODIFIED_TIME_LONG = EXTRACT ( EPOCH FROM LAST_MODIFIED_TIME )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CHANNEL.CREATION_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET CREATION_TIME_LONG = 1000 *
            (   extract(day    from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CHANNEL.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET LAST_MODIFIED_TIME_LONG = 1000 *
            (   extract(day    from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_CHANNEL" column="CREATION_TIME" />
      <schema-deleteColumn table="RHQ_CHANNEL" column="LAST_MODIFIED_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_CHANNEL.CREATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CHANNEL
            RENAME COLUMN CREATION_TIME_LONG
            TO CREATION_TIME
         </statement>
         <statement desc="Renaming new RHQ_CHANNEL.LAST_MODIFIED_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CHANNEL
            RENAME COLUMN LAST_MODIFIED_TIME_LONG
            TO LAST_MODIFIED_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_PACKAGE_VERSION timestamp to long conversion -->
      <schema-addColumn table="RHQ_PACKAGE_VERSION" column="FILE_CREATION_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_PACKAGE_VERSION.FILE_CREATION_TIME timestamp to long">
            UPDATE RHQ_PACKAGE_VERSION
            SET FILE_CREATION_TIME_LONG = EXTRACT ( EPOCH FROM FILE_CREATION_TIME )
            WHERE FILE_CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_PACKAGE_VERSION.FILE_CREATION_TIME timestamp to long">
            UPDATE RHQ_PACKAGE_VERSION
            SET FILE_CREATION_TIME_LONG = 1000 *
            (   extract(day    from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE FILE_CREATION_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_PACKAGE_VERSION" column="FILE_CREATION_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_PACKAGE_VERSION.FILE_CREATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_PACKAGE_VERSION
            RENAME COLUMN FILE_CREATION_TIME_LONG
            TO FILE_CREATION_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_INSTALLED_PACKAGE timestamp to long conversion -->
      <schema-addColumn table="RHQ_INSTALLED_PACKAGE" column="INSTALLATION_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_INSTALLED_PACKAGE.INSTALLATION_TIME timestamp to long">
            UPDATE RHQ_INSTALLED_PACKAGE
            SET INSTALLATION_TIME_LONG = EXTRACT ( EPOCH FROM INSTALLATION_TIME )
            WHERE INSTALLATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_INSTALLED_PACKAGE.INSTALLATION_TIME timestamp to long">
            UPDATE RHQ_INSTALLED_PACKAGE
            SET INSTALLATION_TIME_LONG = 1000 *
            (   extract(day    from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE INSTALLATION_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_INSTALLED_PACKAGE" column="INSTALLATION_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_INSTALLED_PACKAGE.INSTALLATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_INSTALLED_PACKAGE
            RENAME COLUMN INSTALLATION_TIME_LONG
            TO INSTALLATION_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_INSTALLED_PKG_HIST timestamp to long conversion -->
      <schema-addColumn table="RHQ_INSTALLED_PKG_HIST" column="HISTORY_TIMESTAMP_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_INSTALLED_PKG_HIST.HISTORY_TIMESTAMP timestamp to long">
            UPDATE RHQ_INSTALLED_PKG_HIST
            SET HISTORY_TIMESTAMP_LONG = EXTRACT ( EPOCH FROM HISTORY_TIMESTAMP )
            WHERE HISTORY_TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_INSTALLED_PKG_HIST.HISTORY_TIMESTAMP timestamp to long">
            UPDATE RHQ_INSTALLED_PKG_HIST
            SET HISTORY_TIMESTAMP_LONG = 1000 *
            (   extract(day    from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE HISTORY_TIMESTAMP IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_INSTALLED_PKG_HIST" column="HISTORY_TIMESTAMP" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_INSTALLED_PKG_HIST.HISTORY_TIMESTAMP column to match old schema expectations">
            ALTER TABLE RHQ_INSTALLED_PKG_HIST
            RENAME COLUMN HISTORY_TIMESTAMP_LONG
            TO HISTORY_TIMESTAMP
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.23">
      <schema-addColumn table="RHQ_MEASUREMENT_SCHED" column="MTIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_MEASUREMENT_SCHED.MTIME timestamp to long">
            UPDATE RHQ_MEASUREMENT_SCHED
            SET MTIME_LONG = EXTRACT ( EPOCH FROM MTIME )
            WHERE MTIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_MEASUREMENT_SCHED.MTIME timestamp to long">
            UPDATE RHQ_MEASUREMENT_SCHED
            SET MTIME_LONG = 1000 *
            (   extract(day    from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE MTIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_MEASUREMENT_SCHED" column="MTIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_MEASUREMENT_SCHED.MTIME column to match old schema expectations">
            ALTER TABLE RHQ_MEASUREMENT_SCHED
            RENAME COLUMN MTIME_LONG
            TO MTIME
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.24">
      <schema-directSQL>
         <statement desc="Creating RHQ_MEASUREMENT_BLINE index on SCHEDULE_ID">
            CREATE INDEX rhq_meas_baseline_sid_idx ON rhq_measurement_bline (schedule_id)
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.25">
      <schema-dropTable table="RHQ_MEASUREMENT_OOB" />
      <schema-dropSequence name="rhq_measurement_oob_id_seq" />
   </schemaSpec>

   <schemaSpec version="2.26">
      <schema-directSQL>
         <statement desc="Unscheduling auto-baseline job from Quartz - removing trigger">
            DELETE FROM rhq_qrtz_triggers WHERE trigger_name='org.rhq.enterprise.server.scheduler.jobs.AutoBaselineCalculationJob'
         </statement>
         <statement desc="Unscheduling auto-baseline job from Quartz - removing simple trigger">
            DELETE FROM rhq_qrtz_simple_triggers WHERE trigger_name='org.rhq.enterprise.server.scheduler.jobs.AutoBaselineCalculationJob'
         </statement>
         <statement desc="Unscheduling auto-baseline job from Quartz - removing job details">
            DELETE FROM rhq_qrtz_job_details WHERE job_name='org.rhq.enterprise.server.scheduler.jobs.AutoBaselineCalculationJob'
         </statement>
      </schema-directSQL>
   </schemaSpec>

</dbupgrade>

</target>

</project>
